<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Title</title>
	<style>
		html, body {
			margin: 0;
			height: 100%;
		}
		#canvas {
			width: 100%;
			height: 100%;
			display: block;
		}
	</style>

</head>
<body>
<canvas id="canvas"></canvas>
<script type="importmap">
	{
		"imports": {
			"three": "../..//build/three.module.js",
			"three/addons/": "../../examples/jsm/"
		}
	}
</script>

<script type="module">
	import * as cannon from '../../node_modules/cannon/build/cannon.min.js';
	import * as THREE from 'three';
	import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
	import * as dat from 'three/addons/libs/lil-gui.module.min.js';
	import Stats from 'three/addons/libs/stats.module.js';

	const canvas = document.querySelector('#canvas');

	// Scene
	const scene = new THREE.Scene();

	// Size
	const sizes = {
		width: window.innerWidth,
		height: window.innerHeight,
	}

	// Camera
	const camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height, 0.1, 100)
	camera.position.set(4, 4, 15)

	// Controls
	const controls = new OrbitControls(camera, canvas)
	controls.enableDamping = true
	controls.zoomSpeed = 0.3

	/**
	 * Objects
	 */
	// material
	const material = new THREE.MeshStandardMaterial()

	// sphere
	const sphere = new THREE.Mesh(new THREE.SphereGeometry(1, 16, 16), material)
	sphere.position.setY(1)
	sphere.castShadow = true
	scene.add(sphere)

	// plane
	const plane = new THREE.Mesh(new THREE.PlaneGeometry(15, 15), material)
	plane.rotateX(-Math.PI / 2)
	plane.receiveShadow = true
	scene.add(plane)

	/**
	 * Light
	 */
	const directionLight = new THREE.DirectionalLight()
	directionLight.castShadow = true
	directionLight.position.set(5, 5, 6)
	const ambientLight = new THREE.AmbientLight(new THREE.Color('#ffffff'), 0.3)
	scene.add(ambientLight, directionLight)

	const directionLightHelper = new THREE.DirectionalLightHelper(directionLight, 2)
	directionLightHelper.visible = false
	scene.add(directionLightHelper)

	// Renderer
	const renderer = new THREE.WebGLRenderer({
		canvas,
		// antialias: true,
	});
	renderer.setSize(sizes.width, sizes.height)
	renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
	renderer.shadowMap.enabled = true


	/**
	 * Debug
	 */
	const gui = new dat.GUI();
	gui.add(controls, 'autoRotate');
	gui.add(controls, 'autoRotateSpeed', 0.1, 10, 0.01);
	gui.add(material, 'wireframe');
	gui.add(directionLightHelper, 'visible').name('directionLightHelper visible');


	const world = new CANNON.World();
	world.gravity.set( 0, - 9.82, 0 );

	const sphereShape = new CANNON.Sphere(1);
	const defaultMaterial = new CANNON.Material('default')
	const defaultContactMaterial = new CANNON.ContactMaterial(defaultMaterial, defaultMaterial, {
		friction: 0.1,
		restitution: 0.7,
	})
	world.addContactMaterial(defaultContactMaterial)

	const sphereBody = new CANNON.Body({
		mass: 1,
		position: new CANNON.Vec3(0, 3, 0),
		shape: sphereShape,
		material: defaultMaterial,
	})


	world.addBody(sphereBody);

	// floor
	const floorShape = new CANNON.Plane()
	const floorBody = new CANNON.Body()
	floorBody.mass = 0
	floorBody.addShape(floorShape)
	world.addBody(floorBody)

	floorBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2)

	floorBody.material = defaultMaterial


	let stats = new Stats();
	// Animations
	const clock = new THREE.Clock();
	let oldElapsedTime = 0;
	const tick = () => {
		stats.begin();
		controls.update();

		const elapsedTime = clock.getElapsedTime();
		const deltaTime = elapsedTime - oldElapsedTime;
		oldElapsedTime = elapsedTime;
		console.log( deltaTime );

		world.step(1 / 60, deltaTime, 3 );
		sphere.position.copy(sphereBody.position);
		// Render
		renderer.render( scene, camera );
		stats.end();
		requestAnimationFrame( tick );
	};

	tick();

</script>
</body>
</html>
